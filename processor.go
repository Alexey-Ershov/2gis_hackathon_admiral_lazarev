package main

import (
	"encoding/json"
	"log"
	"os"
	"strings"

	"io"

	"golang.org/x/text/encoding/charmap"
	"golang.org/x/text/transform"
)

// Define a struct matching the JSON structure
type AutoGenerated struct {
	Choices []struct {
		Message struct {
			Content string `json:"content"`
			Role    string `json:"role"`
		} `json:"message"`
		Index        int    `json:"index"`
		FinishReason string `json:"finish_reason"`
	} `json:"choices"`
	Created int    `json:"created"`
	Model   string `json:"model"`
	Object  string `json:"object"`
	Usage   struct {
		PromptTokens          int `json:"prompt_tokens"`
		CompletionTokens      int `json:"completion_tokens"`
		TotalTokens           int `json:"total_tokens"`
		PrecachedPromptTokens int `json:"precached_prompt_tokens"`
	} `json:"usage"`
}

func MakeHtml(content string) string {

	res := "<p>"
	index := strings.Index(content, "\n\n")
	res = res + content[0:index]
	res = res + "</p><ul>"

	str := content[index+2:]
	newIndex := strings.Index(str, "\n\n")
	for newIndex >= 0 {
		s := str[0 : newIndex-1]
		res = ProcessLiItem(s, res)
		str = str[newIndex+2:]
		newIndex = strings.Index(str, "\n\n")
	}

	res = res + "</ul><p>" + str + "</p>"

	err := os.Remove("output.html")
	if err != nil {

	}

	filename := "output.html"
	err = os.WriteFile(filename, []byte(res), 0644)
	if err != nil {
		log.Fatalf("Failed to write to file: %v", err)
	}

	return res
}

func ProcessLiItem(s string, res string) string {
	indexStar1 := strings.Index(s, "**")
	s = s[indexStar1+2:]
	indexStar2 := strings.Index(s, "**")
	boldStr := s[0:indexStar2]
	s = s[indexStar2+2:]
	res = res + "<li><b>" + boldStr + "</b><ul>"
	is1 := strings.Index(s, "-")
	for is1 >= 0 {
		s1 := s[is1+1:]
		is2 := strings.Index(s1, "-")
		if is2 >= 0 {
			sSmall := s[is1+1 : is2+2]
			res = res + "<li>" + sSmall + "</li>"
			s = s[is2+3:]
			is1 = strings.Index(s, "-")
		}
		if is2 < 0 {
			sSmall := s[is1+1:]
			res = res + "<li>" + sSmall + "</li>"
			is1 = -1
		}
	}
	res = res + "</ul>"
	return res
}

func readJson() string {
	jsonFile, err := os.Open("result.json")
	if err != nil {
		log.Fatalf("Failed to open file: %v", err)
	}
	defer jsonFile.Close()

	decoder := charmap.Windows1251.NewDecoder()
	reader := transform.NewReader(jsonFile, decoder)

	byteValue, err := io.ReadAll(reader)
	if err != nil {
		log.Fatalf("Failed to read file: %v", err)
	}

	// Declare a variable of type Person
	var obj AutoGenerated

	res := ""
	// Unmarshal JSON into the struct
	err = json.Unmarshal(byteValue, &obj)
	if err == nil {
		res = obj.Choices[0].Message.Content
	}
	return res
}

func main() {

	fileStr := readJson()
	MakeHtml(fileStr)

}
