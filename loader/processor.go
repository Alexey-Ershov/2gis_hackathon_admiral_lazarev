package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	"golang.org/x/text/encoding/charmap"
	"golang.org/x/text/transform"
)

// Define a struct matching the JSON structure
type AutoGenerated struct {
	Choices []struct {
		Message struct {
			Content string `json:"content"`
			Role    string `json:"role"`
		} `json:"message"`
		Index        int    `json:"index"`
		FinishReason string `json:"finish_reason"`
	} `json:"choices"`
	Created int    `json:"created"`
	Model   string `json:"model"`
	Object  string `json:"object"`
	Usage   struct {
		PromptTokens          int `json:"prompt_tokens"`
		CompletionTokens      int `json:"completion_tokens"`
		TotalTokens           int `json:"total_tokens"`
		PrecachedPromptTokens int `json:"precached_prompt_tokens"`
	} `json:"usage"`
}

type Info struct {
	Heading     string `json:"heading"`
	Description string `json:"description"`
}

type ResultGenerated struct {
	Description struct {
		Title         string        `json:"title"`
		Image         string        `json:"image"`
		Heading1      string        `json:"heading1"`
		ListPositives []string      `json:"listPositives"`
		MarkedList    []interface{} `json:"markedList"`
		Info          []Info        `json:"info"`
	} `json:"description"`
	ID int `json:"id"`
}

func MakeHtml(content string) ResultGenerated {

	var res ResultGenerated
	res.ID = 1
	res.Description.Title = ""

	index := strings.Index(content, "\n\n")

	str := content[index+2:]
	newIndex := strings.Index(str, "\n\n")
	for newIndex >= 0 {
		s := str[0 : newIndex-1]
		info := ProcessLiItem(s)
		res.Description.Info = append(res.Description.Info, info)
		res.Description.ListPositives = append(res.Description.ListPositives, info.Heading)
		str = str[newIndex+2:]
		newIndex = strings.Index(str, "\n\n")
	}

	err := os.Remove("output.html")
	if err != nil {

	}

	jsonData, err := json.MarshalIndent(res, "", "  ")
	if err != nil {
		fmt.Printf("Error marshaling JSON: %v\n", err)
		return res
	}

	// Write the JSON data to a file.
	// os.WriteFile creates or overwrites "person.json" with the data.
	// The third argument (0644) sets the file permissions (readable by all, writable by owner).
	err = os.WriteFile("output.json", jsonData, 0644)
	if err != nil {
		fmt.Printf("Error writing JSON to file: %v\n", err)
		return res
	}

	return res
}

func ProcessLiItem(s string) Info {
	var result Info
	indexStar1 := strings.Index(s, "**")
	s = s[indexStar1+2:]
	indexStar2 := strings.Index(s, "**")
	boldStr := s[0:indexStar2]
	result.Heading = boldStr
	s = s[indexStar2+2:]

	result.Description = ""

	is1 := strings.Index(s, "-")
	for is1 >= 0 {
		s1 := s[is1+1:]
		is2 := strings.Index(s1, "-")
		if is2 >= 0 {
			sSmall := s[is1+1 : is2+2]
			result.Description = result.Description + " " + sSmall
			s = s[is2+3:]
			is1 = strings.Index(s, "-")
		}
		if is2 < 0 {
			is1 = -1
		}
	}
	sSmall := s[is1+1:]
	result.Description = result.Description + " " + sSmall

	result.Description = strings.ReplaceAll(result.Description, "\n", "")
	result.Description = strings.ReplaceAll(result.Description, "-", "")
	result.Description = strings.TrimSpace(result.Description)

	return result
}

func readJson() string {
	jsonFile, err := os.Open("result.json")
	if err != nil {
		log.Fatalf("Failed to open file: %v", err)
	}
	defer jsonFile.Close()

	decoder := charmap.Windows1251.NewDecoder()
	reader := transform.NewReader(jsonFile, decoder)

	byteValue, err := io.ReadAll(reader)
	if err != nil {
		log.Fatalf("Failed to read file: %v", err)
	}

	// Declare a variable of type Person
	var obj AutoGenerated

	res := ""
	// Unmarshal JSON into the struct
	err = json.Unmarshal(byteValue, &obj)
	if err == nil {
		res = obj.Choices[0].Message.Content
	}
	return res
}

func main() {

	fileStr := readJson()
	json := MakeHtml(fileStr)
	json.ID = 1
}
